### Description
피보나치 수는 F(0) = 0, F(1) = 1일 때, 1 이상의 n에 대하여 F(n) = F(n-1) + F(n-2) 가 적용되는 수 입니다.

예를들어

* F(2) = F(0) + F(1) = 0 + 1 = 1
* F(3) = F(1) + F(2) = 1 + 1 = 2
* F(4) = F(2) + F(3) = 1 + 2 = 3
* F(5) = F(3) + F(4) = 2 + 3 = 5
와 같이 이어집니다.

2 이상의 n이 입력되었을 때, n번째 피보나치 수를 1234567으로 나눈 나머지를 리턴하는 함수, solution을 완성해 주세요.

### 제한사항
* n은 2 이상 100,000 이하인 자연수입니다.

### 입출력 예
|    n    |	 result |
|---------|---------|
|    3    |    2    |
|    5    |    5    |

<br />

---
### Point ⍨
＞ n의 다음 큰 수를 x라고 했을 때, n < x <br />
＞ n의 이진수 1의 갯수 === x의 이진수 1의 갯수 <br />
＞ 위 조건을 만족하는 수 중 가장 작은 수를 반환한다.

### Total elapsed time ⍩
> 15분

### New Thing
피보나치 수는 50번째 피보나치 수만 가더라도 그 수가 엄청나게 불어나기 때문에 <br />
따라서 자바스크립트가 보장하는 정수계산을 넘어서게 되어서 제대로 된 값을 반환하지 못한다.
```javascript
// 자바스크립트에서 보장하는 최대 정수값

Number.MAX_SAFT_INTEGER // 9007199254740991
```
따라서 모듈러 연산의 성질을 이용해야 한다고 한다.

> N으로 나눈 나머지를 반환하는 문제는 십중팔구 "int64도 버티지 못할만큼 숫자가 엄청 커지니까 적당히 나눠라"는 늬앙스입니다. <br />
중간에 모듈러 연산을 안해주면 일찍이 오버플로우가 발생했을테니 오답이죠.

따라서 문제에서 1234567로 나누라는 의미는 "이 문제에서 int 자료형이 버티질 못하니깐 1234567로 나눠서 문제를 해결해라!"라는 말이다. <br />
그리고 그 문제 해결은 모듈러 연산의 **(A + B) % C ≡ ( ( A % C ) + ( B % C) ) % C** 라는 성질을 이용한다. <br />
계산 결과에 매번 1234567로 나눈 나머지를 반환하는 것으로 int 범위 내에 항상 값이 존재함을 보장할 수 있다.